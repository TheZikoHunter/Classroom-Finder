package com.spring.classroom_finder.controller;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.spring.classroom_finder.model.Horaire;
import com.spring.classroom_finder.repository.HoraireRepository;

@RestController
@RequestMapping("/api/horaires")
@CrossOrigin(origins = "http://localhost:4200")
public class HoraireController {

    private final HoraireRepository horaireRepository;

    @Autowired
    public HoraireController(HoraireRepository horaireRepository) {
        this.horaireRepository = horaireRepository;
    }

    /**
     * Get all horaires
     */
    @GetMapping
    public ResponseEntity<List<Horaire>> getAllHoraires() {
        List<Horaire> horaires = horaireRepository.findAll();
        return new ResponseEntity<>(horaires, HttpStatus.OK);
    }

    /**
     * Get horaire by ID
     */
    @GetMapping("/{id}")
    public ResponseEntity<Horaire> getHoraireById(@PathVariable Integer id) {
        Optional<Horaire> horaire = horaireRepository.findById(id);
        return horaire.map(value -> new ResponseEntity<>(value, HttpStatus.OK))
                .orElseGet(() -> new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

    /**
     * Create a new horaire
     */
    @PostMapping
    public ResponseEntity<?> createHoraire(@RequestBody HoraireRequest request) {
        try {
            // Validate the time format and logic
            if (!isValidTimeFormat(request.getHeureDebut()) || !isValidTimeFormat(request.getHeureFin())) {
                return new ResponseEntity<>("Invalid time format. Use HH:MM format", HttpStatus.BAD_REQUEST);
            }

            if (!isValidTimeOrder(request.getHeureDebut(), request.getHeureFin())) {
                return new ResponseEntity<>("Start time must be before end time", HttpStatus.BAD_REQUEST);
            }

            // Check for conflicts
            List<Horaire> conflicts = horaireRepository.findConflictingHoraires(
                request.getJour(), request.getHeureDebut(), request.getHeureFin());
            
            if (!conflicts.isEmpty()) {
                return new ResponseEntity<>("Time slot conflicts with existing horaire", HttpStatus.CONFLICT);
            }

            Horaire horaire = new Horaire(request.getHeureDebut(), request.getHeureFin(), request.getJour());
            Horaire savedHoraire = horaireRepository.save(horaire);
            return new ResponseEntity<>(savedHoraire, HttpStatus.CREATED);
        } catch (Exception e) {
            return new ResponseEntity<>("Error creating horaire: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Update an existing horaire
     */
    @PutMapping("/{id}")
    public ResponseEntity<?> updateHoraire(@PathVariable Integer id, @RequestBody HoraireRequest request) {
        try {
            if (!horaireRepository.existsById(id)) {
                return new ResponseEntity<>("Horaire with id " + id + " not found", HttpStatus.NOT_FOUND);
            }

            // Validate the time format and logic
            if (!isValidTimeFormat(request.getHeureDebut()) || !isValidTimeFormat(request.getHeureFin())) {
                return new ResponseEntity<>("Invalid time format. Use HH:MM format", HttpStatus.BAD_REQUEST);
            }

            if (!isValidTimeOrder(request.getHeureDebut(), request.getHeureFin())) {
                return new ResponseEntity<>("Start time must be before end time", HttpStatus.BAD_REQUEST);
            }

            // Check for conflicts (excluding the current horaire being updated)
            List<Horaire> conflicts = horaireRepository.findConflictingHoraires(
                request.getJour(), request.getHeureDebut(), request.getHeureFin());
            
            conflicts.removeIf(h -> h.getidHoraire() == id);
            
            if (!conflicts.isEmpty()) {
                return new ResponseEntity<>("Time slot conflicts with existing horaire", HttpStatus.CONFLICT);
            }

            Horaire horaire = new Horaire(request.getHeureDebut(), request.getHeureFin(), request.getJour());
            horaire.setidHoraire(id);
            Horaire updatedHoraire = horaireRepository.save(horaire);
            return new ResponseEntity<>(updatedHoraire, HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>("Error updating horaire: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Delete a horaire
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteHoraire(@PathVariable Integer id) {
        if (!horaireRepository.existsById(id)) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        horaireRepository.deleteById(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    /**
     * Get horaires by day
     */
    @GetMapping("/by-day/{jour}")
    public ResponseEntity<List<Horaire>> getHorairesByDay(@PathVariable String jour) {
        List<Horaire> horaires = horaireRepository.findByJour(jour);
        return new ResponseEntity<>(horaires, HttpStatus.OK);
    }

   


   


    /**
     * Check for conflicting horaires
     */
    @GetMapping("/conflicts")
    public ResponseEntity<?> checkConflicts(
            @RequestParam String jour,
            @RequestParam String startTime, 
            @RequestParam String endTime) {
        
        if (!isValidTimeFormat(startTime) || !isValidTimeFormat(endTime)) {
            return new ResponseEntity<>("Invalid time format. Use HH:MM format", HttpStatus.BAD_REQUEST);
        }

        if (!isValidTimeOrder(startTime, endTime)) {
            return new ResponseEntity<>("Start time must be before end time", HttpStatus.BAD_REQUEST);
        }

        List<Horaire> conflicts = horaireRepository.findConflictingHoraires(jour, startTime, endTime);
        return new ResponseEntity<>(conflicts, HttpStatus.OK);
    }

    /**
     * Validate time format (HH:MM)
     */
    private boolean isValidTimeFormat(String time) {
        if (time == null || time.length() != 5) {
            return false;
        }
        return time.matches("^([01]?[0-9]|2[0-3]):[0-5][0-9]$");
    }

    /**
     * Validate that start time is before end time
     */
    private boolean isValidTimeOrder(String startTime, String endTime) {
        try {
            String[] startParts = startTime.split(":");
            String[] endParts = endTime.split(":");
            
            int startHour = Integer.parseInt(startParts[0]);
            int startMinute = Integer.parseInt(startParts[1]);
            int endHour = Integer.parseInt(endParts[0]);
            int endMinute = Integer.parseInt(endParts[1]);
            
            int startTotalMinutes = startHour * 60 + startMinute;
            int endTotalMinutes = endHour * 60 + endMinute;
            
            return startTotalMinutes < endTotalMinutes;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Request DTO for creating/updating horaire
     */
    public static class HoraireRequest {
        private String heureDebut;
        private String heureFin;
        private String jour;

        public HoraireRequest() {}

        public HoraireRequest(String heureDebut, String heureFin, String jour) {
            this.heureDebut = heureDebut;
            this.heureFin = heureFin;
            this.jour = jour;
        }

        public String getHeureDebut() {
            return heureDebut;
        }

        public void setHeureDebut(String heureDebut) {
            this.heureDebut = heureDebut;
        }

        public String getHeureFin() {
            return heureFin;
        }

        public void setHeureFin(String heureFin) {
            this.heureFin = heureFin;
        }

        public String getJour() {
            return jour;
        }

        public void setJour(String jour) {
            this.jour = jour;
        }
    }
}